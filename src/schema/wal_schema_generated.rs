// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod wal {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SERIALIZATION: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SERIALIZATION: i16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SERIALIZATION: [Serialization; 1] = [
  Serialization::Arrow,
];

/// Defines the serialization format used for the primary data payload
/// associated with a WAL entry (e.g., the Arrow IPC Data).
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Serialization(pub i16);
#[allow(non_upper_case_globals)]
impl Serialization {
  /// Apache Arrow IPC (InterProcess Communication) format.
  pub const Arrow: Self = Self(0);

  pub const ENUM_MIN: i16 = 0;
  pub const ENUM_MAX: i16 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Arrow,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Arrow => Some("Arrow"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Serialization {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Serialization {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    let b = flatbuffers::read_scalar_at::<i16>(buf, loc);
    Self(b)
  }}
}

impl flatbuffers::Push for Serialization {
    type Output = Serialization;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) { unsafe {
        flatbuffers::emplace_scalar::<i16>(dst, self.0);
    }}
}

impl flatbuffers::EndianScalar for Serialization {
  type Scalar = i16;
  #[inline]
  fn to_little_endian(self) -> i16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i16) -> Self {
    let b = i16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Serialization {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Serialization {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_METADATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_METADATA: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_METADATA: [Metadata; 4] = [
  Metadata::NONE,
  Metadata::EventMeta,
  Metadata::LogMeta,
  Metadata::TraceMeta,
];

/// A union representing the different types of detailed metadata
/// that a WAL entry can encapsulate. This allows for flexible
/// and extensible metadata structures without overhead for unused types.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Metadata(pub u8);
#[allow(non_upper_case_globals)]
impl Metadata {
  pub const NONE: Self = Self(0);
  pub const EventMeta: Self = Self(1);
  pub const LogMeta: Self = Self(2);
  pub const TraceMeta: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::EventMeta,
    Self::LogMeta,
    Self::TraceMeta,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::EventMeta => Some("EventMeta"),
      Self::LogMeta => Some("LogMeta"),
      Self::TraceMeta => Some("TraceMeta"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Metadata {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Metadata {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }}
}

impl flatbuffers::Push for Metadata {
    type Output = Metadata;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) { unsafe {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }}
}

impl flatbuffers::EndianScalar for Metadata {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Metadata {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Metadata {}
pub struct MetadataUnionTableOffset {}

pub enum EventMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventMeta<'a> {
  type Inner = EventMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }}
}

impl<'a> EventMeta<'a> {
  pub const VT_SERVICE_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EventMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EventMetaArgs<'args>
  ) -> flatbuffers::WIPOffset<EventMeta<'bldr>> {
    let mut builder = EventMetaBuilder::new(_fbb);
    if let Some(x) = args.service_id { builder.add_service_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn service_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EventMeta::VT_SERVICE_ID, None)}
  }
}

impl flatbuffers::Verifiable for EventMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("service_id", Self::VT_SERVICE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct EventMetaArgs<'a> {
    pub service_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EventMetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    EventMetaArgs {
      service_id: None,
    }
  }
}

pub struct EventMetaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventMetaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_service_id(&mut self, service_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EventMeta::VT_SERVICE_ID, service_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EventMetaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EventMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EventMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EventMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EventMeta");
      ds.field("service_id", &self.service_id());
      ds.finish()
  }
}
pub enum LogMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Metadata specific to a 'Log' type WAL entry.
/// This typically includes details about the data written to a log segment.
pub struct LogMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogMeta<'a> {
  type Inner = LogMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }}
}

impl<'a> LogMeta<'a> {
  pub const VT_SCHEMA_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SCHEMA_HASH: flatbuffers::VOffsetT = 6;
  pub const VT_FLIGHT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_ARROW_BUFFER_ID: flatbuffers::VOffsetT = 10;
  pub const VT_SERVICE_ID: flatbuffers::VOffsetT = 12;
  pub const VT_PARTITION_FIELDS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LogMetaArgs<'args>
  ) -> flatbuffers::WIPOffset<LogMeta<'bldr>> {
    let mut builder = LogMetaBuilder::new(_fbb);
    builder.add_arrow_buffer_id(args.arrow_buffer_id);
    builder.add_schema_hash(args.schema_hash);
    builder.add_schema_id(args.schema_id);
    if let Some(x) = args.partition_fields { builder.add_partition_fields(x); }
    if let Some(x) = args.service_id { builder.add_service_id(x); }
    if let Some(x) = args.flight_id { builder.add_flight_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn schema_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(LogMeta::VT_SCHEMA_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn schema_hash(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(LogMeta::VT_SCHEMA_HASH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flight_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogMeta::VT_FLIGHT_ID, None)}
  }
  #[inline]
  pub fn arrow_buffer_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(LogMeta::VT_ARROW_BUFFER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn service_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LogMeta::VT_SERVICE_ID, None)}
  }
  #[inline]
  pub fn partition_fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LogMeta::VT_PARTITION_FIELDS, None)}
  }
}

impl flatbuffers::Verifiable for LogMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("schema_id", Self::VT_SCHEMA_ID, false)?
     .visit_field::<u64>("schema_hash", Self::VT_SCHEMA_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("flight_id", Self::VT_FLIGHT_ID, false)?
     .visit_field::<u64>("arrow_buffer_id", Self::VT_ARROW_BUFFER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("service_id", Self::VT_SERVICE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("partition_fields", Self::VT_PARTITION_FIELDS, false)?
     .finish();
    Ok(())
  }
}
pub struct LogMetaArgs<'a> {
    pub schema_id: u64,
    pub schema_hash: u64,
    pub flight_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub arrow_buffer_id: u64,
    pub service_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub partition_fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LogMetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    LogMetaArgs {
      schema_id: 0,
      schema_hash: 0,
      flight_id: None,
      arrow_buffer_id: 0,
      service_id: None,
      partition_fields: None,
    }
  }
}

pub struct LogMetaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LogMetaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_schema_id(&mut self, schema_id: u64) {
    self.fbb_.push_slot::<u64>(LogMeta::VT_SCHEMA_ID, schema_id, 0);
  }
  #[inline]
  pub fn add_schema_hash(&mut self, schema_hash: u64) {
    self.fbb_.push_slot::<u64>(LogMeta::VT_SCHEMA_HASH, schema_hash, 0);
  }
  #[inline]
  pub fn add_flight_id(&mut self, flight_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogMeta::VT_FLIGHT_ID, flight_id);
  }
  #[inline]
  pub fn add_arrow_buffer_id(&mut self, arrow_buffer_id: u64) {
    self.fbb_.push_slot::<u64>(LogMeta::VT_ARROW_BUFFER_ID, arrow_buffer_id, 0);
  }
  #[inline]
  pub fn add_service_id(&mut self, service_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogMeta::VT_SERVICE_ID, service_id);
  }
  #[inline]
  pub fn add_partition_fields(&mut self, partition_fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LogMeta::VT_PARTITION_FIELDS, partition_fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LogMetaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LogMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogMeta");
      ds.field("schema_id", &self.schema_id());
      ds.field("schema_hash", &self.schema_hash());
      ds.field("flight_id", &self.flight_id());
      ds.field("arrow_buffer_id", &self.arrow_buffer_id());
      ds.field("service_id", &self.service_id());
      ds.field("partition_fields", &self.partition_fields());
      ds.finish()
  }
}
pub enum TraceMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Metadata specific to a 'Trace' type WAL entry.
/// This typically includes details for distributed tracing or operational insights.
pub struct TraceMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TraceMeta<'a> {
  type Inner = TraceMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }}
}

impl<'a> TraceMeta<'a> {
  pub const VT_SERVICE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TENANT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_TIMESTAMP_UNIX_MICROS: flatbuffers::VOffsetT = 8;
  pub const VT_PARTITION_FIELDS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TraceMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TraceMetaArgs<'args>
  ) -> flatbuffers::WIPOffset<TraceMeta<'bldr>> {
    let mut builder = TraceMetaBuilder::new(_fbb);
    builder.add_timestamp_unix_micros(args.timestamp_unix_micros);
    if let Some(x) = args.partition_fields { builder.add_partition_fields(x); }
    if let Some(x) = args.tenant_id { builder.add_tenant_id(x); }
    if let Some(x) = args.service_id { builder.add_service_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn service_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TraceMeta::VT_SERVICE_ID, None)}
  }
  #[inline]
  pub fn tenant_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TraceMeta::VT_TENANT_ID, None)}
  }
  #[inline]
  pub fn timestamp_unix_micros(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(TraceMeta::VT_TIMESTAMP_UNIX_MICROS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn partition_fields(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(TraceMeta::VT_PARTITION_FIELDS, None)}
  }
}

impl flatbuffers::Verifiable for TraceMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("service_id", Self::VT_SERVICE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tenant_id", Self::VT_TENANT_ID, false)?
     .visit_field::<u64>("timestamp_unix_micros", Self::VT_TIMESTAMP_UNIX_MICROS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("partition_fields", Self::VT_PARTITION_FIELDS, false)?
     .finish();
    Ok(())
  }
}
pub struct TraceMetaArgs<'a> {
    pub service_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tenant_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_unix_micros: u64,
    pub partition_fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for TraceMetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    TraceMetaArgs {
      service_id: None,
      tenant_id: None,
      timestamp_unix_micros: 0,
      partition_fields: None,
    }
  }
}

pub struct TraceMetaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TraceMetaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_service_id(&mut self, service_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TraceMeta::VT_SERVICE_ID, service_id);
  }
  #[inline]
  pub fn add_tenant_id(&mut self, tenant_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TraceMeta::VT_TENANT_ID, tenant_id);
  }
  #[inline]
  pub fn add_timestamp_unix_micros(&mut self, timestamp_unix_micros: u64) {
    self.fbb_.push_slot::<u64>(TraceMeta::VT_TIMESTAMP_UNIX_MICROS, timestamp_unix_micros, 0);
  }
  #[inline]
  pub fn add_partition_fields(&mut self, partition_fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TraceMeta::VT_PARTITION_FIELDS, partition_fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TraceMetaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TraceMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TraceMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TraceMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TraceMeta");
      ds.field("service_id", &self.service_id());
      ds.field("tenant_id", &self.tenant_id());
      ds.field("timestamp_unix_micros", &self.timestamp_unix_micros());
      ds.field("partition_fields", &self.partition_fields());
      ds.finish()
  }
}
pub enum FlatbufMetaOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The top-level FlatBuffer for the WAL entry's metadata.
/// This table contains general information about the FlatBuffer payload itself,
/// and then a union for specific metadata variants.
pub struct FlatbufMeta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FlatbufMeta<'a> {
  type Inner = FlatbufMeta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner { unsafe {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }}
}

impl<'a> FlatbufMeta<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 6;
  pub const VT_TIMESTAMP_UNIX_MICROS: flatbuffers::VOffsetT = 8;
  pub const VT_SERIALIZATION: flatbuffers::VOffsetT = 10;
  pub const VT_MAGIC_NUMBER: flatbuffers::VOffsetT = 12;
  pub const VT_META_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_META: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FlatbufMeta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FlatbufMetaArgs<'args>
  ) -> flatbuffers::WIPOffset<FlatbufMeta<'bldr>> {
    let mut builder = FlatbufMetaBuilder::new(_fbb);
    builder.add_timestamp_unix_micros(args.timestamp_unix_micros);
    if let Some(x) = args.meta { builder.add_meta(x); }
    if let Some(x) = args.magic_number { builder.add_magic_number(x); }
    builder.add_serialization(args.serialization);
    builder.add_meta_type(args.meta_type);
    builder.add_flags(args.flags);
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FlatbufMeta::VT_VERSION, Some(1)).unwrap()}
  }
  #[inline]
  pub fn flags(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FlatbufMeta::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp_unix_micros(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(FlatbufMeta::VT_TIMESTAMP_UNIX_MICROS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn serialization(&self) -> Serialization {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Serialization>(FlatbufMeta::VT_SERIALIZATION, Some(Serialization::Arrow)).unwrap()}
  }
  #[inline]
  pub fn magic_number(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FlatbufMeta::VT_MAGIC_NUMBER, None)}
  }
  #[inline]
  pub fn meta_type(&self) -> Metadata {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Metadata>(FlatbufMeta::VT_META_TYPE, Some(Metadata::NONE)).unwrap()}
  }
  #[inline]
  pub fn meta(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FlatbufMeta::VT_META, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn meta_as_event_meta(&self) -> Option<EventMeta<'a>> {
    if self.meta_type() == Metadata::EventMeta {
      self.meta().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { EventMeta::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn meta_as_log_meta(&self) -> Option<LogMeta<'a>> {
    if self.meta_type() == Metadata::LogMeta {
      self.meta().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LogMeta::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn meta_as_trace_meta(&self) -> Option<TraceMeta<'a>> {
    if self.meta_type() == Metadata::TraceMeta {
      self.meta().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TraceMeta::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for FlatbufMeta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("version", Self::VT_VERSION, false)?
     .visit_field::<u8>("flags", Self::VT_FLAGS, false)?
     .visit_field::<u64>("timestamp_unix_micros", Self::VT_TIMESTAMP_UNIX_MICROS, false)?
     .visit_field::<Serialization>("serialization", Self::VT_SERIALIZATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("magic_number", Self::VT_MAGIC_NUMBER, false)?
     .visit_union::<Metadata, _>("meta_type", Self::VT_META_TYPE, "meta", Self::VT_META, false, |key, v, pos| {
        match key {
          Metadata::EventMeta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventMeta>>("Metadata::EventMeta", pos),
          Metadata::LogMeta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogMeta>>("Metadata::LogMeta", pos),
          Metadata::TraceMeta => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TraceMeta>>("Metadata::TraceMeta", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct FlatbufMetaArgs<'a> {
    pub version: u8,
    pub flags: u8,
    pub timestamp_unix_micros: u64,
    pub serialization: Serialization,
    pub magic_number: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub meta_type: Metadata,
    pub meta: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FlatbufMetaArgs<'a> {
  #[inline]
  fn default() -> Self {
    FlatbufMetaArgs {
      version: 1,
      flags: 0,
      timestamp_unix_micros: 0,
      serialization: Serialization::Arrow,
      magic_number: None,
      meta_type: Metadata::NONE,
      meta: None,
    }
  }
}

pub struct FlatbufMetaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FlatbufMetaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u8) {
    self.fbb_.push_slot::<u8>(FlatbufMeta::VT_VERSION, version, 1);
  }
  #[inline]
  pub fn add_flags(&mut self, flags: u8) {
    self.fbb_.push_slot::<u8>(FlatbufMeta::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_timestamp_unix_micros(&mut self, timestamp_unix_micros: u64) {
    self.fbb_.push_slot::<u64>(FlatbufMeta::VT_TIMESTAMP_UNIX_MICROS, timestamp_unix_micros, 0);
  }
  #[inline]
  pub fn add_serialization(&mut self, serialization: Serialization) {
    self.fbb_.push_slot::<Serialization>(FlatbufMeta::VT_SERIALIZATION, serialization, Serialization::Arrow);
  }
  #[inline]
  pub fn add_magic_number(&mut self, magic_number: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlatbufMeta::VT_MAGIC_NUMBER, magic_number);
  }
  #[inline]
  pub fn add_meta_type(&mut self, meta_type: Metadata) {
    self.fbb_.push_slot::<Metadata>(FlatbufMeta::VT_META_TYPE, meta_type, Metadata::NONE);
  }
  #[inline]
  pub fn add_meta(&mut self, meta: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FlatbufMeta::VT_META, meta);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FlatbufMetaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FlatbufMetaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FlatbufMeta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FlatbufMeta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FlatbufMeta");
      ds.field("version", &self.version());
      ds.field("flags", &self.flags());
      ds.field("timestamp_unix_micros", &self.timestamp_unix_micros());
      ds.field("serialization", &self.serialization());
      ds.field("magic_number", &self.magic_number());
      ds.field("meta_type", &self.meta_type());
      match self.meta_type() {
        Metadata::EventMeta => {
          if let Some(x) = self.meta_as_event_meta() {
            ds.field("meta", &x)
          } else {
            ds.field("meta", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Metadata::LogMeta => {
          if let Some(x) = self.meta_as_log_meta() {
            ds.field("meta", &x)
          } else {
            ds.field("meta", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Metadata::TraceMeta => {
          if let Some(x) = self.meta_as_trace_meta() {
            ds.field("meta", &x)
          } else {
            ds.field("meta", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("meta", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `FlatbufMeta`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flatbuf_meta_unchecked`.
pub fn root_as_flatbuf_meta(buf: &[u8]) -> Result<FlatbufMeta, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<FlatbufMeta>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `FlatbufMeta` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_flatbuf_meta_unchecked`.
pub fn size_prefixed_root_as_flatbuf_meta(buf: &[u8]) -> Result<FlatbufMeta, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<FlatbufMeta>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `FlatbufMeta` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flatbuf_meta_unchecked`.
pub fn root_as_flatbuf_meta_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlatbufMeta<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<FlatbufMeta<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `FlatbufMeta` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_flatbuf_meta_unchecked`.
pub fn size_prefixed_root_as_flatbuf_meta_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<FlatbufMeta<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<FlatbufMeta<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a FlatbufMeta and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `FlatbufMeta`.
pub unsafe fn root_as_flatbuf_meta_unchecked(buf: &[u8]) -> FlatbufMeta { unsafe {
  flatbuffers::root_unchecked::<FlatbufMeta>(buf)
}}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed FlatbufMeta and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `FlatbufMeta`.
pub unsafe fn size_prefixed_root_as_flatbuf_meta_unchecked(buf: &[u8]) -> FlatbufMeta { unsafe {
  flatbuffers::size_prefixed_root_unchecked::<FlatbufMeta>(buf)
}}
#[inline]
pub fn finish_flatbuf_meta_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<FlatbufMeta<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_flatbuf_meta_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<FlatbufMeta<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod wal

